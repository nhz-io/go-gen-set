// Generated by: setup
// TypeWriter: set
// Directive: +test on Thing

package main

type ThingSet interface {
	ToSlice() []Thing
	Add(Thing) bool
	Remove(Thing) bool
	Find(Thing) Thing
	Filter(func(ThingSet, Thing) bool) ThingSet
	Contains(Thing) bool
	Union(ThingSet) ThingSet
	Intersect(ThingSet) ThingSet
	Difference(ThingSet) ThingSet
	Size() int
	Iterator() <-chan Thing
	Equals(interface{}) bool
	Clear()
}

type ThingSetImpl struct {
	elements []Thing
}

func NewThingSet(es ...Thing) ThingSet {
	s := &ThingSetImpl{[]Thing{}}

	for _, e := range es {
		s.Add(e)
	}

	return s
}

func (this *ThingSetImpl) ToSlice() []Thing {
	s := make([]Thing, len(this.elements))
	copy(s, this.elements)

	return s
}

func (this *ThingSetImpl) find(e Thing) (Thing, int, bool) {
	for i, el := range this.elements {
		if el.Equals(e) {
			return el, i, true
		}
	}

	return nil, -1, false
}

func (this *ThingSetImpl) Find(e Thing) Thing {
	el, _, _ := this.find(e)
	return el
}

func (this *ThingSetImpl) Filter(f func(ThingSet, Thing) bool) ThingSet {
	s := NewThingSet()

	for _, el := range this.elements {
		if f(this, el) {
			s.Add(el)
		}
	}

	return s
}

func (this *ThingSetImpl) Add(e Thing) bool {
	_, i, found := this.find(e)

	if found {
		this.elements[i] = e
	} else {
		this.elements = append(this.elements, e)
	}

	return !found
}

func (this *ThingSetImpl) Remove(e Thing) bool {
	_, i, found := this.find(e)

	if found {
		l := len(this.elements) - 1
		this.elements[i] = this.elements[l]
		this.elements[l] = nil
		this.elements = this.elements[:l]
	}

	return found
}

func (this *ThingSetImpl) Contains(e Thing) bool {
	_, _, found := this.find(e)
	return found
}

func (this *ThingSetImpl) Union(other ThingSet) ThingSet {
	var s ThingSet
	var els []Thing

	if this.Size() > other.Size() {
		s = NewThingSet(this.elements...)
		els = other.ToSlice()
	} else {
		s = NewThingSet(other.ToSlice()...)
		els = this.elements
	}

	for _, e := range els {
		s.Add(e)
	}

	return s
}

func (this *ThingSetImpl) Intersect(other ThingSet) ThingSet {
	var els []Thing
	s := NewThingSet()

	if this.Size() < other.Size() {
		els = this.elements
	} else {
		els = other.ToSlice()
		other = this
	}

	for _, e := range els {
		if other.Contains(e) {
			s.Add(e)
		}
	}

	return s
}

func (this *ThingSetImpl) Difference(other ThingSet) ThingSet {
	s := NewThingSet()

	for _, e := range this.elements {
		if !other.Contains(e) {
			s.Add(e)
		}
	}

	return s
}

func (this *ThingSetImpl) Iterator() <-chan Thing {
	ch := make(chan Thing)

	go func() {
		for _, e := range this.elements {
			ch <- e
		}
		close(ch)
	}()

	return ch
}

func (this *ThingSetImpl) Clear() {
	this.elements = []Thing{}
}

func (this *ThingSetImpl) Equals(other interface{}) bool {
	if other, ok := other.(ThingSet); ok && this.Size() == other.Size() {
		for _, e := range this.elements {
			if !other.Contains(e) {
				return false
			}
		}

		return true
	}

	return false
}

func (this *ThingSetImpl) Size() int {
	return len(this.elements)
}
